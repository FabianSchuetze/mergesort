\documentclass[xcolor=table]{beamer}
\usepackage{lmodern}
%\usepackage[normalem]{ulem}
\usepackage{ marvosym }
\usepackage[export]{adjustbox}
\usepackage{mathtools,calc}
\newcommand\Fontvi{\fontsize{22}{23.2}\selectfont}
\newcommand\strikeout[2][]{%
 \begin{tabular}[b]{@{}c@{}}
    \makebox(0,0)[cb]{\textcolor{blue}{#1}} \\[-0.2\normalbaselineskip]
     \rlap{\color{red}\rule[0.5ex]{\widthof{#2}}{0.5pt}}#2
 \end{tabular}}

\newcommand<>\mathalt[2]{%
  \alt#3{\mathmakebox[\widthof{$#2$}]{#1}}{#2}%
}
\newcommand{\underbracedmatrix}[2]{%
  \left(\;
  \smash[b]{\underbrace{
    \begin{matrix}#1\end{matrix}
  }_{#2}}
  \;\right)
  \vphantom{\underbrace{\begin{matrix}#1\end{matrix}}_{#2}}
}
\usepackage{colortbl}
\usepackage{minted}
\usepackage{booktabs}
%\usepackage{xcolor}
%\usepackage[usenames, dvipsnames]{color}
\definecolor{red}{rgb}{0.894, 0.101, 0.109} 
\definecolor{Gray}{gray}{0.85}
\newcolumntype{a}{>{\columncolor{Gray}}c}
\definecolor{green}{rgb}{0.1054, 0.6171, 0.4648}
\definecolor{orange}{rgb}{0.8476, 0.3711, 0.0078}
\definecolor{violet}{rgb}{0.9023, 0.1602, 0.5391}
\usepackage[doi=false, backref=true, url=false, isbn=false, backend=biber,
                        citestyle=authoryear]{biblatex}
\usepackage{tabu}
\newcommand{\blue}{\textcolor{blue}}
\newcommand{\red}{\textcolor{red}}
\newcommand{\green}{\textcolor{green}}
\newcommand{\organge}{\textcolor{orange}}
\newcommand{\violet}{\textcolor{violet}}
% Just for demo

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}
\usepackage{mathtools}
\newtheorem{prop}{Proposition}
\newtheorem{hypothesis}{Hypothesis}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{makecell} % to make linebreaks in table
\renewcommand\theadalign{bc}
\renewcommand\theadfont{\bfseries}
\renewcommand\theadgape{\Gape[4pt]}
\renewcommand\cellgape{\Gape[4pt]}
\usepackage{hhline}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage[]{hyperref}%
\hypersetup{colorlinks, linkcolor={blue}, citecolor={blue}, urlcolor={red}}
\usepackage{graphicx}

\DeclareMathOperator*{\argmax}{\arg\!\max}
\DeclareMathOperator{\E}{\mathbb{E}}
\addbibresource[]{library.bib}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\setbeamertemplate{caption}{\raggedright\insertcaption\par}
\usetheme{default}
\usepackage[flushleft]{threeparttable}
\usepackage{booktabs,caption,fixltx2e}
\usepackage{ragged2e}
\usepackage{appendixnumberbeamer}
\makeatletter
\usefonttheme{professionalfonts}
\usefonttheme{serif}
\setbeamertemplate{navigation symbols}{}%remove navigation symbols
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertsection\
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertsubsection\
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
    %\usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em} % hide %date
    %\insertframenumber{} / \inserttotalframenumber\hspace*{2ex} 
  \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatother
%\setbeamertemplate{footline}[frame number]{}


\usepackage{listings}
\lstset{
    tabsize=4,
    showstringspaces=false,
    numbers=left,
    commentstyle=\color{green},
    keywordstyle=\color{blue},
    stringstyle=\color{red}
}


 %----------------------------------------------------------------------------------------
% %	TITLE PAGE
% %----------------------------------------------------------------------------------------
\renewcommand*{\thefootnote}{\fnsymbol{footnote}}
\title[]{Mergesort with CUDA}
\date{25.02.2020} % Date, can be changed to a custom date
%\author{Fabian Schuetze, EUI}
\addtobeamertemplate{block begin}{}{\justifying}  %new code
\setbeamertemplate{itemize items}[circle]

\usepackage{tikz, enumitem}
\usetikzlibrary{positioning}% for positioning of nodes
\usetikzlibrary{decorations.pathreplacing,positioning, arrows.meta}
\newcommand{\ImageWidth}{11cm}


\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}
\frametitle{GPUs is fast and easily programmable}
    \red{Fast:} See number of flops
    \red{Easy:} CUDA: Extension to C-language, called from C/C++
\end{frame}

\begin{frame}
\tableofcontents
\end{frame}


\section{Simple Program and Big Architecture Ideas}

\begin{frame}[fragile]
\frametitle{A Simple Cuda Programm}
\begin{overlayarea}{\textwidth}{7.1cm}
%\only<1->{
\begin{onlyenv}<1->
\green{1: Call Cuda Program from C/C++:}
\begin{minted}[linenos=true]{cpp}
dim3 Grid(2)
dim3 Block(4)
add_arrays<<<Grid, Block>>>(...)
\end{minted}
\end{onlyenv}
%}
\begin{onlyenv}<2->
    \green{2: Blocks \& Grid spawn many threads on GPU:}
\begin{figure}
    \centering
\begin{tikzpicture}
% draw horizontal line
\draw[thick,- ] (0,0) -- (3,0) node[font=\scriptsize,below left=3pt and
        -5pt]{};
\draw[thick,- ] (5,0) -- (8,0) node[font=\scriptsize,below left=3pt and
        -5pt]{};


% draw vertical lines
\foreach \x in {0,1,...,3}
\draw (\x cm,3pt) -- (\x cm,-3pt);

\foreach \x in {5,6,...,8}
\draw (\x cm,3pt) -- (\x cm,-3pt);

\foreach \x/\descr in {0/Thread 0,3/Thread 3}
\node[font=\scriptsize, text height=1.75ex,
text depth=.5ex] at (\x,-.3) {$\descr$};

\foreach \x/\descr in {5/Thread 0,8/Thread 3}
\node[font=\scriptsize, text height=1.75ex,
text depth=.5ex] at (\x,-.3) {$\descr$};

\draw [thick ,decorate,decoration={brace,amplitude=5pt}] (3.5,-0.5)  -- +(-4,0) 
       node [black,midway,below=4pt, font=\scriptsize] {Block 0};
\draw [thick ,decorate,decoration={brace,amplitude=5pt}] (8.5,-0.5)  -- +(-4,0) 
       node [black,midway,below=4pt, font=\scriptsize] {Block 1};
\end{tikzpicture}
\end{figure}
%}
%\only<3->{
\end{onlyenv}
\begin{onlyenv}<3->
\green{3: Cuda Code is a C-Extension:}
\begin{minted}[linenos=true]{cuda}
__global__ 
add_arrays(float* A, float* B, float* C, int n) {
    int i = blockDim.x * blockIdx.x + threadIdx.x;
    if (i < n) {
        C[i] = A[i] + B[i];
    }
}
\end{minted}
\end{onlyenv}
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]
\frametitle{Software/Hardware interface}
\begin{overlayarea}{\textwidth}{4.5cm}
\begin{onlyenv}<1>
\begin{figure}
    \centering
\begin{minted}[linenos=true]{cpp}
dim3 Grid(2)
dim3 Block(4)
add_arrays<<<Grid, Block>>>(...)
\end{minted}
\end{figure}
\end{onlyenv}
\only<2>{
\begin{figure}[ht]
   \centering
   \includegraphics[scale=0.25]{cuda_architecture.png}
\end{figure}
 }
\only<3>{
\begin{figure}[ht]
   \centering
   \includegraphics[scale=0.25]{sm_dispatch.png}
\end{figure}
}
\end{overlayarea}
\begin{overlayarea}{\textwidth}{3.0cm}
\only<1->{
\red{1. Software:} Specify Blocks and Threads\\
}
\only<2->{
\red{2. Hardware:\\}
\green{1. Blocks to SM:} Block 1 $\rightarrow$ SM1, Block 2 $\rightarrow$
    SM2 $\ldots$\\
}
\only<3->{
\green{2. Threads to Processors:} Wrappend threads are allocated\\
}
\end{overlayarea}
\end{frame}

\begin{frame}
\frametitle{Reasons for strong GPU performance}

\begin{overlayarea}{\textwidth}{5.0cm}
\only<1>{
\begin{figure}[ht]
\centering
\includegraphics[scale=0.30]{amd.png}
\end{figure}
}
\only<2>{
\begin{figure}[ht]
\centering
\includegraphics[scale=0.30]{cuda_architecture.png}
\end{figure}
}
\only<3>{
\begin{figure}[ht]
\centering
\includegraphics[scale=0.30]{sm_dispatch.png}
\end{figure}
}
\end{overlayarea}
\begin{overlayarea}{\textwidth}{3.0cm}
\only<1->{
    \red{CPU:} Chip full with fancy Branch Prediction, Caches, etc.
}
\only<2->{
\red{GPU:\\} 
    1. \green{Simplicity:} Just Cores on chip\\
}
    \only<3->{
    2.  \green{Multithreading:} Wrap 1 in a long-latency op: Start Wrap 2
}
\end{overlayarea}
\end{frame}

%\begin{frame}[fragile]
%\frametitle{GPU and CPU uses different memories}
%\begin{figure}[ht]
   %\centering
   %\includegraphics[scale=0.7]{architecture.png}
%\end{figure}
%\green{Init:}
%\begin{minted}[linenos=true]{cpp}
%T* gpup;
%int sz = 10*sizeof(int);
%cudaMalloc((void**)&gpup, sz);
%\end{minted}
%\green{Memory Transfer:}
%\begin{minted}[linenos=true]{cpp}
%cudaMemcpy(gpup, cpup, nBytes, cudaMemcpyHostToDevice);
%\end{minted}
%\end{frame}

%\begin{frame}[fragile]
%\frametitle{Ideas for Memory Management}
%\begin{minted}[linenos=true]{cpp}
%class Storage {
   %public:
    %explicit Storage(const std::vector<T>&);

   %private:
    %std::vector<T> _data;
    %T* _cpu_pointer;
    %T* _gpu_pointer;
    %void initialize_gpu_memory();
%};
%\end{minted}
%\begin{itemize}
    %\item Memory pool, takes ownership
    %\item Initializes the gpu memory as copy
    %\item Pointers for cpu/gpu locations
%\end{itemize}
%\end{frame}

%\begin{frame}[fragile]
    %\frametitle{Lazy Memory Sync}
%\begin{minted}[linenos=true]{cpp}
%class Storage {
   %public:
    %T* cpu_pointer();
    %T* gpu_pointer();
    %const T* cpu_pointer_const();
    %const T* gpu_pointer_const();

   %private:
    %std::string head; \\ head = {CPU, GPU, SYNC}
    %void sync_to_cpu();
    %void sync_to_gpu();
%};
%\end{minted}
%\green{Example:}
%\begin{itemize}
    %\item After Initialization: \mintinline{c++}{head = SYNC}
    %\item Access, \mintinline{c++}{gpu_pointer_const(): head} remains
    %\item Access \mintinline{c++}{cpu_pointer(): head = CPU}
    %\item Acess \mintinline{c++}{gpu_pointer(): sync_to_cpu(); head = SYNC}
%\end{itemize}
%\end{frame}

%\section{Mapping Cuda calls to Hardware}

\section{Merge}

\begin{frame}[fragile]
\frametitle{Serial Merge}
\setlength\abovedisplayskip{-2.0pt}
\begin{align*}
    A &= \begin{bmatrix} 5 & 7 & 8& 12 \end{bmatrix} \\
    B &= \begin{bmatrix} 3&  4&  6&  10 \end{bmatrix} \\
        C &= \begin{bmatrix} ?&  ?&  ?&  ?&  ?&  ?&  ?& ? \end{bmatrix}
\end{align*}
\begin{minted}[linenos=true]{c++}
void merge(T* a, T* b, T* c, int sz_a, int sz_b) {
    int i = 0, j = 0, k = 0;
    while (k < sz_a + sz_b)
        if (i == sz_a)
            c[k++] = b[j++];
        else if (j == sz_b)
            c[k++] = a[i++];
        else if (a[i] <= b[j])
            c[k++] = a[i++];
        else
            c[k++] = b[j++];
}
\end{minted}
\red{Problem:} complexity, $\mathcal{O}(n)$
\end{frame}

\begin{frame}
\frametitle{How to split A and B to spwan many threads?}
\begin{overlayarea}{\textwidth}{10cm}
\only<1->{
\green{Example:}
\begin{align*}
    A &= \begin{matrix} 0 & 0&0&0 \end{matrix} \\
    B &= \begin{matrix} 1&1&1&1 \end{matrix} \\
    C &= \begin{matrix} ?&?&?&?&?&?&?&? \end{matrix}
\end{align*}
}
\only<2->{
\green{Naive:} 2 Threads, half A and B
%\begin{align*}
    %A &=  \smash[b]{\block{Thread 1}} & \smash[b]{\block{Thread
    %2}}  \\
    %B &= 2
    %B &= \begin{matrix} \underbrace{1 & 1}_{\text{Thread 1}} | 
    %\underbrace{1 & 1}_{\text{Thread 2}} \end{matrix} \\
    %C &= \begin{matrix} \underbrace{? &?& ?& ?}_{\text{Thread 1}} | 
    %\underbrace{?& ?& ?& ?}_{\text{Thread 2}} \end{matrix}
%\end{align*}
}
\only<3->{
\green{Result:}
%\begin{align*}
    %C &= \begin{matrix} \underbrace{0& 0& 1& 1}_{\text{Thread 1}} | 
    %\underbrace{0& 0& 1& 1}_{\text{Thread 2}} \end{matrix}
%\end{align*}
}
\end{overlayarea}
\end{frame}

\begin{frame}
\frametitle{Instead: How to split arrays}
\textcite{odeh_merge_2012}
\begin{overlayarea}{\textwidth}{7.4cm}
\only<1>{
   \begin{figure}[ht]
       \centering
       \textbf{How to split two arrays in equal chuncks?}
       \includegraphics[scale=0.22]{initial.png}
    \end{figure}
 }
\only<2>{
   \begin{figure}[ht]
   \centering
       \textbf{Feasible split: Array A to Thread 1, B to Thread 2}
   \includegraphics[scale=0.22]{feasible_1.png}
    \end{figure}
 }
\only<3>{
   \begin{figure}[ht]
   \centering
   \textbf{Another split: Array B to Thread 1,  A to Thread 2}
   \includegraphics[scale=0.22]{feasible_2.png}
    \end{figure}
 }
\only<4>{
   \begin{figure}[ht]
   \centering
   \textbf{Another (as before): Thread 1 gets half of A and B}
   \includegraphics[scale=0.22]{feasible_3.png}
    \end{figure}
    \red{Summary:} All allocations along vertical line split work equally!
 }
\only<5>{
   \begin{figure}[ht]
   \centering
   \textbf{Mergepath: Optimal split: One Elemet of B}
   \includegraphics[scale=0.22]{mergepath_1.png}
    \end{figure}
    \green{Summary:} All allocations along vertical line split work equally!
    \green{Mergpath:} Vertical move: pick array B; horizontal move: Array
 }
\only<6>{
   \begin{figure}[ht]
   \centering
   \textbf{Mergepath: Optimal split: Another Elemet of B}
   \includegraphics[scale=0.22]{mergepath_2.png}
    \end{figure}
    \green{Summary:} All allocations along vertical line split work equally!
    \green{Mergpath:} Vertical move: pick array B; horizontal move: Array
 }
\only<7>{
   \begin{figure}[ht]
   \centering
   \textbf{Mergepath: Optimal split: Another Elemet of B}
   \includegraphics[scale=0.22]{mergepath_3.png}
    \end{figure}
    \green{Summary:} All allocations along vertical line split work equally!
    \green{Mergpath:} Vertical move: pick array B; horizontal move: Array
 }
\only<8>{
   \begin{figure}[ht]
   \centering
   \textbf{Mergepath: Optimal split: Another Elemet of B}
   \includegraphics[scale=0.22]{mergepath_4.png}
    \end{figure}
    \green{Summary:} All allocations along vertical line split work equally!
    \green{Mergpath:} Vertical move: pick array B; horizontal move: Array
 }
\only<9>{
   \begin{figure}[ht]
   \centering
   \textbf{Mergepath: Optimal split: First elment of A}
   \includegraphics[scale=0.22]{mergepath_5.png}
    \end{figure}
    \green{Summary:} All allocations along vertical line split work equally!
    \green{Mergpath:} Vertical move: pick array B; horizontal move: Array
 }
\only<10>{
\begin{figure}[ht]
\centering
\textbf{Mergepath: Optimal split!}
\includegraphics[scale=0.22]{mergepath_6.png}
\end{figure}
\green{Split index of A:} 3\\
\green{Split index of B:} 5
 }
\end{overlayarea}
\end{frame}

\begin{frame}[fragile]
\frametitle{Merge with Cuda}
\begin{minted}[linenos=true]{cuda}
__global__ 
void paralleMerge(int* a, int sz_a, int* b, int sz_b, 
                  int* c, int length)
{
    int diag = threadIdx.x * length;
    int a_split = mergepath(a, sz_a, b, sz_b, diag);
    int b_split = diag - a_split;
    merge(a, a_split, sz_a, b, b_split, sz_b, c, diag, length);
}
\end{minted}
\begin{itemize}
    \item Each identifies split indices
    \item Split indices suffice to merge two sub-arrays into c
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Problem: Slow as a Snail}
\begin{figure}[ht]
\centering
\includegraphics[scale=0.35]{global_memory_merge.png}
\end{figure}
\end{frame}

\begin{frame}
\frametitle{Reason: So much global meory access}
\begin{overlayarea}{\textwidth}{5.0cm}
\only<1>{
\begin{figure}[ht]
\centering
\includegraphics[scale=0.25]{memory_access_pattern_1.png}
\end{figure}
}
\only<2>{
\begin{figure}[ht]
\centering
\includegraphics[scale=0.25]{memory_access_pattern_3.png}
\end{figure}
}
\end{overlayarea}
\end{frame}

\section{Memory Hirachy of CUDA}
\begin{frame}
\frametitle{Different Memories and Size}
\begin{figure}[ht]
\centering
\includegraphics[scale=0.40]{memory_hirachy.png}
\end{figure}
\red{Visibility:\\}
\green{Global $\Leftrightarrow$ Shared:} All threads $\Leftrightarrow$
        Private for Block\\
\red{Size:\\}
\green{Global $\Leftrightarrow$ Shared:} 2 GB $\Leftrightarrow$
    Total: 192 KB, per block: 48 KB\\
\red{Latency:\\}
\green{Global $\Leftrightarrow$ Shared:} 8 GB/s $\Leftrightarrow$
    80 GB/s
\end{frame}

\section{Merging with local memory}
\begin{frame}
\frametitle{General Idea}
\red{Problem:} Block shared memory:  48 Kb -> need to make blocks small enough\\
\red{Solution:}
\begin{itemize}
    \item Determine large but small enough chuncks of arrays to load into blocks
    \item Load into shared memeory
    \item Each thread determines its range (as before), from shared memory
    \item Each thread merges subset (as before)
\end{itemize}
\end{frame}

\begin{frame}[fragile]
%\begin{minted}[linenos=true]{cuda}
%__global__ 
%void paralleMerge(int* a, int sz_a, int* b, int sz_b, 
                  %int* c, int length)
%{
    %int diag = threadIdx.x * length;
    %int a_start = mergepath(a, sz_a, b, sz_b, diag);
    %int b_start = diag - a_start;
    %merge(a, a_start, sz_a, b, b_start, sz_b, c, diag, length);
%}
%\end{minted}
\begin{minted}[linenos=true]{cuda}
__global__ 
void paralleMerge(const int* a, int sz_a, const int* b, int sz_b,
                 int* c, int* boundaries, int length,
                 int size_shared) {
    extern __shared__ int shared[];
    __shared__ int block_ranges[4];
    ranges(block_ranges, sz_a, sz_b, boundaries);
    loadtodevice(a, sz_a, b, sz_b, block_ranges, shared);
    int diag = threadIdx.x * length;
    if (diag < block_ranges[2] + block_ranges[3]) {
        int a_start =
            mergepath(shared, block_ranges[2], &shared[block_ranges[2]],
                      block_ranges[3], diag);
        int b_start = diag - a_start;
        merge(shared, a_start, block_ranges[2], &shared[block_ranges[2]],
              b_start, block_ranges[3], c, diag + blockIdx.x * size_shared,
              length);
    }
}
\end{minted}
\end{frame}

\begin{frame}
\frametitle{Show the results}
\begin{figure}[ht]
\centering
\includegraphics[scale=0.22]{shared_memory_merge.png}
\end{figure}
\end{frame}

\begin{frame}[t,allowframebreaks]
\printbibliography[]
\end{frame}
\end{document}
